/*
Alldebrid API

Welcome to the OpenAPI Alldebrid API v4 !<br /> You can use this API to access various Alldebrid services from custom applications or scripts.<br /> <br /> API is organized around REST,<br /> returns JSON-encoded responses and use standard HTTP response codes.<br /> <br /> All calls are to be made on the HTTPS endpoints.<br /> Some are public, others require to be authentificated with an apikey (see Authentication).<br /> <br /> You must also identify your apps or script with a meaningfull agent parameter.<br /> <br /> This API version is namespaced as v4, as such all endpoint start with /v4/,<br /> such like http://api.alldebrid.com/v4/ping?agent=apiShowcase.<br /> <br /> This API v4 should be the final version regarding general response format and errors (hopefully).<br />

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiHostsDomainsGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
}

// Your software user-agent.
func (r ApiHostsDomainsGetRequest) Agent(agent string) ApiHostsDomainsGetRequest {
	r.agent = &agent
	return r
}

func (r ApiHostsDomainsGetRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.HostsDomainsGetExecute(r)
}

/*
HostsDomainsGet Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array.

Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array.<br /> <br /> This will also include any alternative domain the hosts or redirectors have.<br /> Please use regexps availables in /hosts or /user/hosts endpoints to validate supported links.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsDomainsGetRequest
*/
func (a *DefaultApiService) HostsDomainsGet(ctx _context.Context) ApiHostsDomainsGetRequest {
	return ApiHostsDomainsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2001
func (a *DefaultApiService) HostsDomainsGetExecute(r ApiHostsDomainsGetRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HostsDomainsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts/domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHostsGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	hostOnly *string
}

// Your software user-agent.
func (r ApiHostsGetRequest) Agent(agent string) ApiHostsGetRequest {
	r.agent = &agent
	return r
}
// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiHostsGetRequest) HostOnly(hostOnly string) ApiHostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiHostsGetRequest) Execute() (InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.HostsGetExecute(r)
}

/*
HostsGet Use this endpoint to retrieve informations about what hosts we support.

Use this endpoint to retrieve informations about what hosts we support and all related informations about it.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsGetRequest
*/
func (a *DefaultApiService) HostsGet(ctx _context.Context) ApiHostsGetRequest {
	return ApiHostsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *DefaultApiService) HostsGetExecute(r ApiHostsGetRequest) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HostsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	if r.hostOnly != nil {
		localVarQueryParams.Add("hostOnly", parameterToString(*r.hostOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHostsPriorityGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
}

// Your software user-agent.
func (r ApiHostsPriorityGetRequest) Agent(agent string) ApiHostsPriorityGetRequest {
	r.agent = &agent
	return r
}

func (r ApiHostsPriorityGetRequest) Execute() (InlineResponse2002, *_nethttp.Response, error) {
	return r.ApiService.HostsPriorityGetExecute(r)
}

/*
HostsPriorityGet Not all hosts are created equal, so some hosts are more limited than other.

Use this endpoint to retrieve an ordered list of main domain of hosts, from more open to more restricted.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsPriorityGetRequest
*/
func (a *DefaultApiService) HostsPriorityGet(ctx _context.Context) ApiHostsPriorityGetRequest {
	return ApiHostsPriorityGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2002
func (a *DefaultApiService) HostsPriorityGetExecute(r ApiHostsPriorityGetRequest) (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2002
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HostsPriorityGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts/priority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkDelayedGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	id *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkDelayedGetRequest) Agent(agent string) ApiLinkDelayedGetRequest {
	r.agent = &agent
	return r
}
// Delayed ID received in /link/unlock.
func (r ApiLinkDelayedGetRequest) Id(id string) ApiLinkDelayedGetRequest {
	r.id = &id
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkDelayedGetRequest) Apikey(apikey string) ApiLinkDelayedGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkDelayedGetRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.LinkDelayedGetExecute(r)
}

/*
LinkDelayedGet This endpoint give the status of a delayed link.

This endpoint give the status of a delayed link.<br /> <br /> Some links need time to generate, this endpoint send the status of such delayed links.<br /> <br /> You should pool every 5 seconds or more the link/delayed endpoint until given the download link.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkDelayedGetRequest
*/
func (a *DefaultApiService) LinkDelayedGet(ctx _context.Context) ApiLinkDelayedGetRequest {
	return ApiLinkDelayedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2009
func (a *DefaultApiService) LinkDelayedGetExecute(r ApiLinkDelayedGetRequest) (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LinkDelayedGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/delayed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkInfosGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	link *[]string
	apikey *string
	password *string
}

// Your software user-agent.
func (r ApiLinkInfosGetRequest) Agent(agent string) ApiLinkInfosGetRequest {
	r.agent = &agent
	return r
}
// The link or array of links you request informations about.
func (r ApiLinkInfosGetRequest) Link(link []string) ApiLinkInfosGetRequest {
	r.link = &link
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkInfosGetRequest) Apikey(apikey string) ApiLinkInfosGetRequest {
	r.apikey = &apikey
	return r
}
// Link password (supported on uptobox / 1fichier).
func (r ApiLinkInfosGetRequest) Password(password string) ApiLinkInfosGetRequest {
	r.password = &password
	return r
}

func (r ApiLinkInfosGetRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	return r.ApiService.LinkInfosGetExecute(r)
}

/*
LinkInfosGet Use this endpoint to retrieve informations about a link.

Use this endpoint to retrieve informations about a link.<br /> If it is in our systems, you'll have the filename and size (if available).<br /> <br /> If the host is not supported or the link is down, an error will be<br /> returned for that link.<br /> <br /> This endpoint only support host links, not redirectors links. Use the<br /> link/redirector endpoint for this.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkInfosGetRequest
*/
func (a *DefaultApiService) LinkInfosGet(ctx _context.Context) ApiLinkInfosGetRequest {
	return ApiLinkInfosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2005
func (a *DefaultApiService) LinkInfosGetExecute(r ApiLinkInfosGetRequest) (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LinkInfosGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/infos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	if r.password != nil {
		localVarQueryParams.Add("password", parameterToString(*r.password, ""))
	}
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("link[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("link[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkRedirectorGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	link *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkRedirectorGetRequest) Agent(agent string) ApiLinkRedirectorGetRequest {
	r.agent = &agent
	return r
}
// The redirector or protector link to extract links.
func (r ApiLinkRedirectorGetRequest) Link(link string) ApiLinkRedirectorGetRequest {
	r.link = &link
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkRedirectorGetRequest) Apikey(apikey string) ApiLinkRedirectorGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkRedirectorGetRequest) Execute() (InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.LinkRedirectorGetExecute(r)
}

/*
LinkRedirectorGet Use this endpoint to retrieve links protected by a redirector or link protector.

Use this endpoint to retrieve links protected by a redirector or link protector.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkRedirectorGetRequest
*/
func (a *DefaultApiService) LinkRedirectorGet(ctx _context.Context) ApiLinkRedirectorGetRequest {
	return ApiLinkRedirectorGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2006
func (a *DefaultApiService) LinkRedirectorGetExecute(r ApiLinkRedirectorGetRequest) (InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LinkRedirectorGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/redirector"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("link", parameterToString(*r.link, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkStreamingGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	id *string
	stream *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkStreamingGetRequest) Agent(agent string) ApiLinkStreamingGetRequest {
	r.agent = &agent
	return r
}
// The link ID you received from the /link/unlock call.
func (r ApiLinkStreamingGetRequest) Id(id string) ApiLinkStreamingGetRequest {
	r.id = &id
	return r
}
// The stream ID you choosed from the stream qualities list returned by /link/unlock.
func (r ApiLinkStreamingGetRequest) Stream(stream string) ApiLinkStreamingGetRequest {
	r.stream = &stream
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkStreamingGetRequest) Apikey(apikey string) ApiLinkStreamingGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkStreamingGetRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.LinkStreamingGetExecute(r)
}

/*
LinkStreamingGet The unlocking flow for streaming link is a bit more complex.

First hit the usual link/unlock endpoint. Two cases:<br /> <br /> Stream link has only one quality : downloading link is available immediatly.<br /> <br /> OR<br /> <br /> Stream links has multiple qualities : you must select the desired<br /> quality to obtain a download link or delayed id by using the<br /> link/streaming endpoint.<br /> <br /> Depending of the stream website, you'll either get a download link, or a<br /> delayed id (see Delayed link section for delayed links).<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkStreamingGetRequest
*/
func (a *DefaultApiService) LinkStreamingGet(ctx _context.Context) ApiLinkStreamingGetRequest {
	return ApiLinkStreamingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2008
func (a *DefaultApiService) LinkStreamingGetExecute(r ApiLinkStreamingGetRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LinkStreamingGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/streaming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.stream == nil {
		return localVarReturnValue, nil, reportError("stream is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("stream", parameterToString(*r.stream, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkUnlockGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	link *string
	apikey *string
	password *string
}

// Your software user-agent.
func (r ApiLinkUnlockGetRequest) Agent(agent string) ApiLinkUnlockGetRequest {
	r.agent = &agent
	return r
}
// The redirector or protector link to extract links.
func (r ApiLinkUnlockGetRequest) Link(link string) ApiLinkUnlockGetRequest {
	r.link = &link
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkUnlockGetRequest) Apikey(apikey string) ApiLinkUnlockGetRequest {
	r.apikey = &apikey
	return r
}
// Link password (supported on uptobox / 1fichier).
func (r ApiLinkUnlockGetRequest) Password(password string) ApiLinkUnlockGetRequest {
	r.password = &password
	return r
}

func (r ApiLinkUnlockGetRequest) Execute() (InlineResponse2007, *_nethttp.Response, error) {
	return r.ApiService.LinkUnlockGetExecute(r)
}

/*
LinkUnlockGet This endpoint unlocks a given link.

This endpoint can return a delayed ID. In that case, you must follow the delayed link flow.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkUnlockGetRequest
*/
func (a *DefaultApiService) LinkUnlockGet(ctx _context.Context) ApiLinkUnlockGetRequest {
	return ApiLinkUnlockGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2007
func (a *DefaultApiService) LinkUnlockGetExecute(r ApiLinkUnlockGetRequest) (InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LinkUnlockGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("link", parameterToString(*r.link, ""))
	if r.password != nil {
		localVarQueryParams.Add("password", parameterToString(*r.password, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetDeleteGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	id *string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetDeleteGetRequest) Agent(agent string) ApiMagnetDeleteGetRequest {
	r.agent = &agent
	return r
}
// Magnet ID.
func (r ApiMagnetDeleteGetRequest) Id(id string) ApiMagnetDeleteGetRequest {
	r.id = &id
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetDeleteGetRequest) Apikey(apikey string) ApiMagnetDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetDeleteGetRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.MagnetDeleteGetExecute(r)
}

/*
MagnetDeleteGet Delete a magnet.

Delete a magnet.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetDeleteGetRequest
*/
func (a *DefaultApiService) MagnetDeleteGet(ctx _context.Context) ApiMagnetDeleteGetRequest {
	return ApiMagnetDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20013
func (a *DefaultApiService) MagnetDeleteGetExecute(r ApiMagnetDeleteGetRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetInstantGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	magnets *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetInstantGetRequest) Agent(agent string) ApiMagnetInstantGetRequest {
	r.agent = &agent
	return r
}
// Magnets URI or hash you wish to check instant availability, can be one or many links
func (r ApiMagnetInstantGetRequest) Magnets(magnets []string) ApiMagnetInstantGetRequest {
	r.magnets = &magnets
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetInstantGetRequest) Apikey(apikey string) ApiMagnetInstantGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetInstantGetRequest) Execute() (InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.MagnetInstantGetExecute(r)
}

/*
MagnetInstantGet Check if a magnet is available instantly.

Check if a magnet is available instantly.<br /> You can either send the magnets in GET parameters, or in POST.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetInstantGetRequest
*/
func (a *DefaultApiService) MagnetInstantGet(ctx _context.Context) ApiMagnetInstantGetRequest {
	return ApiMagnetInstantGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20015
func (a *DefaultApiService) MagnetInstantGetExecute(r ApiMagnetInstantGetRequest) (InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetInstantGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/instant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.magnets == nil {
		return localVarReturnValue, nil, reportError("magnets is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	{
		t := *r.magnets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("magnets[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("magnets[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetRestartGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	ids *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetRestartGetRequest) Agent(agent string) ApiMagnetRestartGetRequest {
	r.agent = &agent
	return r
}
// Array of Magnet ID.
func (r ApiMagnetRestartGetRequest) Ids(ids []string) ApiMagnetRestartGetRequest {
	r.ids = &ids
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetRestartGetRequest) Apikey(apikey string) ApiMagnetRestartGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetRestartGetRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.MagnetRestartGetExecute(r)
}

/*
MagnetRestartGet Restart a failed magnet, or multiple failed magnets at once.

Restart a failed magnet, or multiple failed magnets at once.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetRestartGetRequest
*/
func (a *DefaultApiService) MagnetRestartGet(ctx _context.Context) ApiMagnetRestartGetRequest {
	return ApiMagnetRestartGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20014
func (a *DefaultApiService) MagnetRestartGetExecute(r ApiMagnetRestartGetRequest) (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetRestartGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ids", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetStatusGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
	id *string
	status *string
	session *string
	counter *string
}

// Your software user-agent.
func (r ApiMagnetStatusGetRequest) Agent(agent string) ApiMagnetStatusGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetStatusGetRequest) Apikey(apikey string) ApiMagnetStatusGetRequest {
	r.apikey = &apikey
	return r
}
// Magnet ID.
func (r ApiMagnetStatusGetRequest) Id(id string) ApiMagnetStatusGetRequest {
	r.id = &id
	return r
}
// Magnets status filter. Either active, ready, expired or error
func (r ApiMagnetStatusGetRequest) Status(status string) ApiMagnetStatusGetRequest {
	r.status = &status
	return r
}
// Session ID for Live mode (see Live Mode).
func (r ApiMagnetStatusGetRequest) Session(session string) ApiMagnetStatusGetRequest {
	r.session = &session
	return r
}
// Counter for Live mode (see Live Mode).
func (r ApiMagnetStatusGetRequest) Counter(counter string) ApiMagnetStatusGetRequest {
	r.counter = &counter
	return r
}

func (r ApiMagnetStatusGetRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.MagnetStatusGetExecute(r)
}

/*
MagnetStatusGet Get the status of current magnets, or only one if you specify a magnet ID.

Get the status of current magnets, or only one if you specify a magnet ID.<br /> !TODO: Add live magnet status.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetStatusGetRequest
*/
func (a *DefaultApiService) MagnetStatusGet(ctx _context.Context) ApiMagnetStatusGetRequest {
	return ApiMagnetStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20012
func (a *DefaultApiService) MagnetStatusGetExecute(r ApiMagnetStatusGetRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.session != nil {
		localVarQueryParams.Add("session", parameterToString(*r.session, ""))
	}
	if r.counter != nil {
		localVarQueryParams.Add("counter", parameterToString(*r.counter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetUploadFilePostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
	file **os.File
}

// Your software user-agent.
func (r ApiMagnetUploadFilePostRequest) Agent(agent string) ApiMagnetUploadFilePostRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetUploadFilePostRequest) Apikey(apikey string) ApiMagnetUploadFilePostRequest {
	r.apikey = &apikey
	return r
}
func (r ApiMagnetUploadFilePostRequest) File(file *os.File) ApiMagnetUploadFilePostRequest {
	r.file = &file
	return r
}

func (r ApiMagnetUploadFilePostRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	return r.ApiService.MagnetUploadFilePostExecute(r)
}

/*
MagnetUploadFilePost Upload torrent files.

Upload torrent files.<br /> This endpoint should be POSTed on.<br /> It expects a multipart formdata file upload.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetUploadFilePostRequest
*/
func (a *DefaultApiService) MagnetUploadFilePost(ctx _context.Context) ApiMagnetUploadFilePostRequest {
	return ApiMagnetUploadFilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20011
func (a *DefaultApiService) MagnetUploadFilePostExecute(r ApiMagnetUploadFilePostRequest) (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetUploadFilePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/upload/file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "[]file"

	var fileLocalVarFile *os.File
	if r.file != nil {
		fileLocalVarFile = *r.file
	}
	if fileLocalVarFile != nil {
		fbs, _ := _ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetUploadGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	magnets *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetUploadGetRequest) Agent(agent string) ApiMagnetUploadGetRequest {
	r.agent = &agent
	return r
}
// Magnet(s) URI or hash. Must send magnet either in GET param or in POST data.
func (r ApiMagnetUploadGetRequest) Magnets(magnets []string) ApiMagnetUploadGetRequest {
	r.magnets = &magnets
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetUploadGetRequest) Apikey(apikey string) ApiMagnetUploadGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetUploadGetRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	return r.ApiService.MagnetUploadGetExecute(r)
}

/*
MagnetUploadGet Upload a magnet with its URI or hash.

Upload a magnet with its URI or hash.<br /> You can either send the magnets in GET parameters, or in POST.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetUploadGetRequest
*/
func (a *DefaultApiService) MagnetUploadGet(ctx _context.Context) ApiMagnetUploadGetRequest {
	return ApiMagnetUploadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20010
func (a *DefaultApiService) MagnetUploadGetExecute(r ApiMagnetUploadGetRequest) (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MagnetUploadGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.magnets == nil {
		return localVarReturnValue, nil, reportError("magnets is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	{
		t := *r.magnets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("magnets[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("magnets[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserGetRequest) Agent(agent string) ApiUserGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserGetRequest) Apikey(apikey string) ApiUserGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserGetRequest) Execute() (InlineResponse2003, *_nethttp.Response, error) {
	return r.ApiService.UserGetExecute(r)
}

/*
UserGet Use this endpoint to get user informations.

Use this endpoint to get user informations.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserGetRequest
*/
func (a *DefaultApiService) UserGet(ctx _context.Context) ApiUserGetRequest {
	return ApiUserGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2003
func (a *DefaultApiService) UserGetExecute(r ApiUserGetRequest) (InlineResponse2003, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2003
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHistoryDeleteGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserHistoryDeleteGetRequest) Agent(agent string) ApiUserHistoryDeleteGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHistoryDeleteGetRequest) Apikey(apikey string) ApiUserHistoryDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserHistoryDeleteGetRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.UserHistoryDeleteGetExecute(r)
}

/*
UserHistoryDeleteGet Use this endpoint to delete all links currently in your recent links history.

Use this endpoint to delete all links currently in your recent links history.<br /> Links older than 3 days are automatically deleted from the recent history.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHistoryDeleteGetRequest
*/
func (a *DefaultApiService) UserHistoryDeleteGet(ctx _context.Context) ApiUserHistoryDeleteGetRequest {
	return ApiUserHistoryDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20019
func (a *DefaultApiService) UserHistoryDeleteGetExecute(r ApiUserHistoryDeleteGetRequest) (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserHistoryDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/history/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHistoryGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserHistoryGetRequest) Agent(agent string) ApiUserHistoryGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHistoryGetRequest) Apikey(apikey string) ApiUserHistoryGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserHistoryGetRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.UserHistoryGetExecute(r)
}

/*
UserHistoryGet Use this endpoint to get recent links.

Use this endpoint to get recent links.<br /> Recent link logging being disabled by default,<br /> this will return nothing until history logging has been activated in your account settings.<br /> <br /> Links older than 3 days are automatically deleted from the recent history.<br /> To keep links in your account, use the Saved links.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHistoryGetRequest
*/
func (a *DefaultApiService) UserHistoryGet(ctx _context.Context) ApiUserHistoryGetRequest {
	return ApiUserHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20016
func (a *DefaultApiService) UserHistoryGetExecute(r ApiUserHistoryGetRequest) (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHostsGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
	hostOnly *string
}

// Your software user-agent.
func (r ApiUserHostsGetRequest) Agent(agent string) ApiUserHostsGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHostsGetRequest) Apikey(apikey string) ApiUserHostsGetRequest {
	r.apikey = &apikey
	return r
}
// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiUserHostsGetRequest) HostOnly(hostOnly string) ApiUserHostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiUserHostsGetRequest) Execute() (InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.UserHostsGetExecute(r)
}

/*
UserHostsGet This endpoint retrieves a complete list of all available hosts for this user.

This endpoint retrieves a complete list of all available hosts for this user.<br /> Depending of the account subscription status (free user, trial mode, premium user),<br /> the list and limitations will vary.<br /> <br /> The limits and quota are updated in real time. Use this page to have an<br /> up-to-date list of service the user can use on Alldebrid.<br /> <br /> Quotas will reset every day for premium users.<br />

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHostsGetRequest
*/
func (a *DefaultApiService) UserHostsGet(ctx _context.Context) ApiUserHostsGetRequest {
	return ApiUserHostsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *DefaultApiService) UserHostsGetExecute(r ApiUserHostsGetRequest) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserHostsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	if r.hostOnly != nil {
		localVarQueryParams.Add("hostOnly", parameterToString(*r.hostOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksDeleteGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
	link *string
	link2 *[]string
}

// Your software user-agent.
func (r ApiUserLinksDeleteGetRequest) Agent(agent string) ApiUserLinksDeleteGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksDeleteGetRequest) Apikey(apikey string) ApiUserLinksDeleteGetRequest {
	r.apikey = &apikey
	return r
}
// Link to delete.
func (r ApiUserLinksDeleteGetRequest) Link(link string) ApiUserLinksDeleteGetRequest {
	r.link = &link
	return r
}
// Links to delete.
func (r ApiUserLinksDeleteGetRequest) Link2(link2 []string) ApiUserLinksDeleteGetRequest {
	r.link2 = &link2
	return r
}

func (r ApiUserLinksDeleteGetRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.UserLinksDeleteGetExecute(r)
}

/*
UserLinksDeleteGet Delete a saved link.

Delete a saved link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksDeleteGetRequest
*/
func (a *DefaultApiService) UserLinksDeleteGet(ctx _context.Context) ApiUserLinksDeleteGetRequest {
	return ApiUserLinksDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20018
func (a *DefaultApiService) UserLinksDeleteGetExecute(r ApiUserLinksDeleteGetRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserLinksDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	if r.link != nil {
		localVarQueryParams.Add("link", parameterToString(*r.link, ""))
	}
	if r.link2 != nil {
		t := *r.link2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("link[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("link[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserLinksGetRequest) Agent(agent string) ApiUserLinksGetRequest {
	r.agent = &agent
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksGetRequest) Apikey(apikey string) ApiUserLinksGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserLinksGetRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.UserLinksGetExecute(r)
}

/*
UserLinksGet Use this endpoint to get links the user saved for later use.

Use this endpoint to get links the user saved for later use.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksGetRequest
*/
func (a *DefaultApiService) UserLinksGet(ctx _context.Context) ApiUserLinksGetRequest {
	return ApiUserLinksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20016
func (a *DefaultApiService) UserLinksGetExecute(r ApiUserLinksGetRequest) (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserLinksGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksSaveGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	link *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiUserLinksSaveGetRequest) Agent(agent string) ApiUserLinksSaveGetRequest {
	r.agent = &agent
	return r
}
// Links to save.
func (r ApiUserLinksSaveGetRequest) Link(link []string) ApiUserLinksSaveGetRequest {
	r.link = &link
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksSaveGetRequest) Apikey(apikey string) ApiUserLinksSaveGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserLinksSaveGetRequest) Execute() (InlineResponse20017, *_nethttp.Response, error) {
	return r.ApiService.UserLinksSaveGetExecute(r)
}

/*
UserLinksSaveGet Save a link.

Save a link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksSaveGetRequest
*/
func (a *DefaultApiService) UserLinksSaveGet(ctx _context.Context) ApiUserLinksSaveGetRequest {
	return ApiUserLinksSaveGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20017
func (a *DefaultApiService) UserLinksSaveGetExecute(r ApiUserLinksSaveGetRequest) (InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse20017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserLinksSaveGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links/save"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("link[]", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("link[]", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserNotificationClearGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	agent *string
	code *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserNotificationClearGetRequest) Agent(agent string) ApiUserNotificationClearGetRequest {
	r.agent = &agent
	return r
}
// Notification code to clear
func (r ApiUserNotificationClearGetRequest) Code(code string) ApiUserNotificationClearGetRequest {
	r.code = &code
	return r
}
// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserNotificationClearGetRequest) Apikey(apikey string) ApiUserNotificationClearGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserNotificationClearGetRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.UserNotificationClearGetExecute(r)
}

/*
UserNotificationClearGet This endpoint clears a user notification with its code.

This endpoint clears a user notification with its code. Current notifications codes can be retreive from the /user endpoint.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserNotificationClearGetRequest
*/
func (a *DefaultApiService) UserNotificationClearGet(ctx _context.Context) ApiUserNotificationClearGetRequest {
	return ApiUserNotificationClearGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2004
func (a *DefaultApiService) UserNotificationClearGetExecute(r ApiUserNotificationClearGetRequest) (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UserNotificationClearGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/notification/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}

	if r.apikey != nil {
		localVarQueryParams.Add("apikey", parameterToString(*r.apikey, ""))
	}
	localVarQueryParams.Add("agent", parameterToString(*r.agent, ""))
	localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
